# 1. 单周期处理器概念

　　单周期是指一个时钟周期完成一条指令，在时钟沿控制下，处理器依次串行地执行指令序列。

　　在RISC处理器中，完成一条指令一般经过如下阶段：

| 阶段 | 描述 |
| ---- | ---- |
| 取指（Instruction Fetch, IF）| 根据PC（Program Counter）提供的指令地址，从指令存储器中读取指令 |
| 指令译码（Instruction Decode, ID）| 分析取出的指令，根据指令操作码（Opcode）产生控制信号 |
| 执行（Execute, EX） | 在控制信号的控制下，进行具体运算等操作。该阶段将产生指令执行的结果 |
| 访存（Load/Store, LS）| 该阶段访问数据存储器。对于Load指令，访存阶段从数据存储器中读出指定地址单元的数据；对于Store指令，访存阶段将数据写入指定地址单元。|
| 写回（Write Back, WB）| 将指令执行的结果写入到寄存器堆中。|

　　上述五个阶段在一个时钟周期中完成，译码、执行阶段都是组合逻辑，且各阶段之间没有并行，这就是单周期处理器的工作方式。

# 2. 单周期处理器的微架构

　　本次实现的单周期处理器由PC、指令译码单元（IDU）、分支控制单元（BRU）、算术逻辑单元（ALU）、指令和数据存储器构成，微架构如下图所示：

![microarch](figures/microarch.png) 

　　图中蓝色有向边表示数据通路，红色有向边表示控制通路。

　　PC是一个寄存器（reg），维护待取出的指令的地址。在处理器上电复位时，PC中的值为程序开始运行的起始地址，若不发生转移，即控制信号`br_sel=0`、`rel_sel=1`，则当下一个时钟沿到来时，PC的值将置为PC+ILEN，即下一条指令的地址。

　　BRU处理控制转移指令的细节。在RISC-V指令集中，控制转移指令的目标地址主要有两种寻址模式：寄存器寻址和PC相对寻址，前者的目标地址来自寄存器堆，因此设计从ALU到PC的数据通路`br_tgt`，设置控制信号`br_sel=1`，`fu_sel=MOV`，即可在PC寄存器输入端口获得目标地址；而后者目标地址是PC与立即数提供的偏移量相加，通过设置控制信号`rel_sel=0`，`br_sel=0`，可获得PC相对寻址得到的目标地址。另一方面，控制转移指令主要分为无条件跳转（Unconditional Jumps）和条件分支（Conditional Branches）两种类型，对于后者，BRU需要检查来自ALU的进位/溢出/零等标志位，确定分支条件是否满足，从而决定是否产生控制转移信号。

　　IDU分析从IRAM取出的指令，产生控制信号。`op_sel`控制操作数是来自寄存器堆、零扩展（zero-extends）立即数还是符号扩展（sign-extends）立即数；`fu_sel`控制ALU的功能；`mem_rw`控制是否读写数据RAM，`wb_sel`控制指令结果是来自ALU结果还是数据RAM读出的数据。

　　ALU是执行部分的核心部件，根据控制信号`op_sel`完成两操作数`A`、`B`的算术（加、减等）和逻辑（与、或等）运算，运算结果通过`result`输出。

　　DRAM是数据存储器。当控制信号`mem_rw=1`时，将操作数写入`ADDR`对应的单元中，反之从`ADDR`对应内存单元中读出数据。RISC-V指令集中Load/Store指令使用基地址+偏移量寻址模式，在本次设计的微架构中，访存地址由ALU产生，`op_sel=1`,`fu_sel=ADD`，ALU输出即为寄存器中的基地址与立即数偏移量相加所得地址。


# 3. 问题思考

* （1）ALU的输入（两个操作数`A`、`B`）都取自寄存器堆，而ALU的输出又回到了寄存器堆，从逻辑上讲似乎产生了闭环，如何考虑这个问题？
  ——寄存器堆本质是用触发器实现，触发器只在时钟沿将数据锁存到输出，其余时刻输出与输入无关，不存在逻辑环路。即当前周期ALU输出A与B的运算结果，在下一周期结果才写入`rd`指定的寄存器。这里根本上是组合逻辑和时序逻辑的区别。


* （2）如果下一周期指令的操作数刚好来自上一周期写入的寄存器，是否会出现问题？

  ——由（1）可知，下一周期时上周期的结果已经写入寄存器，再从寄存器读时可以取到正确的操作数。

# 4. 2021-7-11：RAM的实现

DRAM写入时序：

![microarch](figures/dram_write.png) 

# 5. 2021-7-12：ALU的实现

目前已经实现的ALU内部操作码：

| 内部操作码 | 描述 |
| ---- | ---- | 
| (1<<0) | ADD |
| (1<<1) | SUB |
| (1<<2) | AND |
| (1<<3) | OR |
| (1<<4) | XOR |
| (1<<5) | SLL |
| (1<<6) | SRL |

# 6. 2021-7-13：ADDI指令的实现

用于测试的addi指令序列：

```assembly
addi x1, x0, 123
addi x2, x1, 4
addi x3, x2, 4
addi x4, x3, 4
addi x5, x4, 4
addi x6, x5, 4
addi x7, x6, 4
addi x8, x7, 4
addi x31, x8, 4
```

CPU执行上述指令序列产生的波形：

![microarch](figures/addi.png)

可以观察到，x1首先被置为123，接着x2被置为123+4 = 127，余下的指令按照上述序列依次执行。测试结果是正常的。


# 参考资料

[1] The RISC-V Instruction Set Manual Volume 1, Unprivileged Spec v. 20191213

[2] 唐朔飞. 计算机组成原理.第2版[M]. 高等教育出版社, 2008.


